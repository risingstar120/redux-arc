<img src="https://github.com/viniciusdacal/redux-arc/blob/master/arc-64.png?raw=true" height="64" />

Create scalable, no-boilerplate redux Apps!

Arc is an abstraction layer to help you reduce boilerplate on redux-apps and also, organize better your code. Additionally, it has utilities to handle async requests.

[![build status](https://img.shields.io/travis/viniciusdacal/redux-arc/master.svg?style=flat-square)](https://travis-ci.org/viniciusdacal/redux-arc) [![npm version](https://img.shields.io/npm/v/redux-arc.svg?style=flat-square)](https://www.npmjs.com/package/redux-arc)
[![Coverage Status](https://coveralls.io/repos/github/viniciusdacal/redux-arc/badge.svg?branch=master)](https://coveralls.io/github/viniciusdacal/redux-arc?branch=master)

## Creators and types are generated by a config

```js
  // actions.js
  import { createActions } from 'redux-arc';

  export { types, creators } = createActions('jedis', {
    add: null,
  });
```

## Create reducers using types

```js
  import { createReducers } from 'redux-arc';
  import { types } from './actions';

  const INITIAL_STATE = [];
  const HANDLERS = {
    [types.ADD]: (state, action) => [...state, action.payload]
  };

  export default createReducers(INITIAL_STATE, HANDLERS);
```

## Call the creators providing payload and meta

```js
  import { creators } from './actions';

  const payload = {
    name: 'Luke',
    master: 'Yoda',
  };
  const meta = { foo: 'bar' };

  dispatch(creators.add(payload, meta))
```

## Why
Redux is awesome! But people often complain about how much boilerplate they have to write when using it. Part of this problem, is because they feel unproductive defining constants, action creators and big reducers, but also because they don't have a clear idea on how to organize their project, or even how to proper handle async requests. This project, intends to help on all that aspects!

We don't intend to recreate the wheel, instead, we tried to use what the community are used with, and build up some approaches together in order to clarify the things about the project architecture, code splitting and the things around actions.

To understand this docs, you should have a good understand of redux: what are Action creators, what are reducers, middlewares and also, what is a Flux Standard Action. So please, if you need a recap on those concepts, read the links bellow:

[Redux Docs](https://redux.js.org/)
[Flux Standard Action](https://github.com/acdlite/flux-standard-action)



# Action creators and Types
When you have to create a new action on redux, the first 2 steps you usually do is defining a **const** to you *action type* and then defining an *action creator*.

```js
const NEW_JEDI = 'NEW_JEDI';

const newJedi = (payload) => ({
  type: NEW_JEDI,
  payload,
});
```

The above code is fine, but the problem is, you have dozens or hundreds of action in an application, and you are always writing the same code. Also, if you are not strict on code review, you end up having situations where your action type has a name different from your action creator:

```js
const NEW_JEDI = 'NEW_JEDI';

const addJedi = (payload) => ({
  type: NEW_JEDI,
  payload,
});
```

Thinking in the above issues, Arc has a `createAction` function, that you use to define your actions and it generates the types and action creators automatically for you. Take a look:

```js
  import { createActions } from 'redux-arc';

  const { types, creators } = createActions('yourNamespace', {
    newJedi: null,
  });

  types.newJedi // YOUR_NAMESPACE_NEW_JEDI

  const payload = {
    master: 'Yoda',
    name: 'Luke',
  };

  creators.newJedi(payload);
  /*
  {
    type: 'YOUR_NAMESPACE_NEW_JEDI',
    payload: {
      master: 'Yoda',
      name: 'Luke',
    }
  }
  */
```

The `createActions` method, expects a namespace as its first argument, this will be uppercased and will serve as a prefix for the actions. As the second parameter, we need to provide a config object, which the key is the action name and the value is an object with default values for **payload** and **meta**, or `null` if you don't want to provide defaults. Then, it will return **creators** and **types**.

Both creators and types are objects, the first one contains the action creators for the actions you defined. As in the case above we defined an action newJedi, then we have a creator at `creators.newJedi`.

Creators accepts until three arguments:
 - payload: could be of any type. Will become the `action.payload`
 - meta: could be of any type. Will become the `action.meta`
 - error: boolean. Indicates if the action has an error or not. You can omit it if the action has no error.

> The api was designed following the flux-standard-action concepts. It can be strict about how your action should look like, but this will help you creating better actions. Also, now you can be sure that the first parameter you provide to the action creator, will become the action.payload.

The types is an object that contains strings. Its keys are the action names, but different from the creators, here they are uppercased:

```
  types.NEW_JEDI
```

Also, when you do a console.log to see its content, you can see that we prefix the actions with the namespace you provided:

```
  const { types } = createActions('yourNamespace' {
    newJedi: null,
  });

  types.NEW_JEDI // -> YOUR_NAMESPACE_NEW_JEDI

```

> We decided to have the namespace, to not stop you from having actions with the same name in different modules. Don't worry, you will be able to differ them easily when using redux-dev-tools, just remember to provide unique namespaces.






